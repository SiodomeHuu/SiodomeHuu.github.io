# 编译原理

## 背景

就是编译器相关的东西。

除了编译本身外还有许多链接相关的知识。

## 大致内容

词法分析(token流)，语法分析(树)，语义分析(抽象语法树)，中间代码生成，机器无关的优化。

* 词法分析

	主要内容就是正规式。写过正则表达式的应该都比较清楚。刨去一些基本的概念和定义外，其实就是识别字母、数字、符号，并且抽象成单词流。

	其实就是用一个描述串去描述许许多多的满足要求的串。描述串里可以描述子串之间的这些关系：连接，或，闭包。连接：s与t -> st。或：s或者t -> s|t。 闭包： (s)* 。或的意思是串对应的地方允许是s或者是t，闭包的意思是这之间允许若干(0到无穷)个s在这里。

	说的有点抽象，举个例子；要描述C语言里面的标识符：

	Number = 0|1|2|3|4|5|6|7|8|9

	Alpha = A|B|C|...|Z|a|b|c|...|z

	Identifier = ( Alpha | _ ) (Alpha | _ | Number)*

	首先，Number与Alpha定义为纯数字/字母。Identifier要求第一个为字母或者下划线，后面为数字、下划线或者字母的组成。很明显，第二个以后用一个闭包即可实现。

	**要注意，有一个特殊的符号，ε，表示空串。**

	最原始的符号只有连接、或与闭包。其他我们可以使用(包括正则表达式里)的符号都可以用这几个符号来表示。

	? 表示前面的一项可有可无。 (s)? 可以表示为 (s|ε)。

	+表示前面的一项重复1到无穷次。(s)+可以表示为(s|ε)(s)*。

	[a-zA-Z0-9] 直接用基本的或运算。表示匹配ASCII一个区间的字符

	再比如，数字常量：

	NumDecConst = [1-9] [0-9]* ( (e|E) (+|-)? [1-9] [0-9]* )?

	NumOctConst = 0 [0-7]*

	NumHexConst = 0 x [0-9a-fA-F]+

* 语法分析

	纯粹根据token流构造语法树。语法分析使用的描述范式比词法分析的正规式描述能力更强，没有把二者合并的原因是词法分析可以去额外处理诸如字符集啊编程语言之类的琐事。

	**语法(syntax)和文法(grammar)的区别是，不同的文法可能描述着相同的语法。**

	文法由起始符、终结符、非终结符和推导式组成。推导式就是讲每个非终结符可以怎么推导。比如：

	F -> 'e' F | 'w'

	现在给定你一句： eeeeew 还有起始非终结符F，你要判断可不可以推导。这个时候有两种思路：

	第一种是，看到第一个是e，那只能用 F-> 'e' F这个推导式。第二个还是e，那么就继续用，直到看到最后一个w，使用F->'w'：

	F->eF->eeF->eeeF->...->eeeeeF->eeeeew

	这种就是所谓的LL文法。第一个L的意思是从左往右读取token流，第二个L的意思是最左推导，即看到足够的最左侧的信息就完成**预测**。

	第二种是，等有足够多的信息，看到最右侧后才做出**归约**，即LR文法；第一个L一样，第二个的R表示最右推导。具体是：

	eeeeew 看到最后一个w，才使用F->'w'推导式；然后变为eeeeeF，看到顶部的eF，然后使用F->eF，依次向上，最后栈里就剩下F，归约成功。

	这一块核心就是根据这里展开的。LL一般就会谈到LL(1)，而LR有SLR(1)[S代表简单的意思]，正规LR(1)与LALR(1)。

	LL(1)就是指往前看**1个字符**就决定使用什么推导式，当看一个后有两个以上的推导式就会出问题；而且左递归(如F->Fx)一定不是LL文法。SLR(1)也即LR(0)，是根据目前有的信息就决定作归约还是移进，而LR(1)在SLR(1)基础上，要看下一个字符才决定归约还是移进，所以LR(1)表达能力肯定比SLR(1)要强；LALR(1)则是合并了LR(1)的同心项。

* 语义分析

	根据语法分析生成的语法树，我们可能需要处理或者增加/删减部分信息，重新获得一棵树。当然，也有可能边做语法分析边做语义分析。这里面有几项而已：**语法制导定义 翻译方案 栈操作代码**

	比如刚才的那个例子，我们要统计e的个数，可以这么写：

	F -> e F1  F.enum=F1.enum+1

	F -> w     F.enum=0

	以上是语法制导定义，同时也是翻译方案。

	简单而言，翻译方案比语法制导定义复杂，翻译方案需要给出运行你写的代码的时机，比如是归约后运行？还是读取到一半的token就执行？另外，在这里的enum叫属性，属于综合属性，另外还有继承属性——综合属性是左边属性等于右边属性做运算，继承属性是右边的属性需要左边的数据。

	F -> e F1  stack[top-1]=stack[top]+1

	F -> w     stack[top]=0

	以上是栈操作代码(假定为满栈，即top指向元素而不是空地)。假设栈里面放的就是各个属性值，然后直接去操作各个属性。

* 中间代码生成

	根据语义分析出来的抽象语法树，生成抽象代码。最主要的也就是几种控制语句啊表达式啊怎么翻译成抽象代码(比如三地址代码，比如LLVM的IR)。

	还是举个例子吧，比如翻译一个有如下语法定义的简单的if语句：

	If -> 'if' '(' Exp ')' Block

	假设翻译成抽象语法树后，一个if语句会得到个tuple，则：

	tuple[2].analyze(); 将Exp翻译成代码
	
	jz label

	tuple[4].analyze(); 将Block翻译为代码

	label: 此处插入个label

	然后就可以继续翻译了。

	这一段还是有点概念比如单赋值(SSA)还有基本块的概念。单赋值就是说每个变量只允许赋值一次，比如变量t，你可以t1=i;然后t2=j;这样有助于以后的优化；基本块就是说，一整段代码必须线性执行；只有在结尾处可以跳走，并且外界跳转必须跳转到开头。

* 抽象代码优化

	常量折叠、复写传播、死代码删除...都是些概念性的。真正要做优化有更深入的算法，没学...

## 整体过一遍

举个C语言的例子吧。

词法分析： 删除多余的空格与注释，所有标识符啊符号啊数啊关键字啊全部排成数组。

语法分析： 将你的程序变为树的形式。有多少个函数啊，多少个变量定义声明啊，整体构成一棵树。

语义分析： 可以和语法分析一起做的。当然因为课程用的antlr，语法分析和语义分析是分开的，语法分析后是一棵数据量非常大的语法树，从中捡出你必要的信息来构建抽象语法树(比如这个阶段就可以去除一些关键字token，因为已经做过语法分析了)。比如一个if语句，你可以就记录个Exp和Block，而不用记录'if' '(' ')'之类的token。

抽象代码生成： 遍历之前的抽象语法树，生成机器无关的代码。

## 总结

无感。课程实现C子集实在让人提不起兴趣，即使用其他语言会加大难度。

希望有朝一日能自己实现虚拟机，然后实现个翻译到这个虚拟机的编译器。