# 程序设计语言(C语言)

[返回](/)

## 背景

大一第一门也是唯一一门的计算机相关的必修课，也是全校通修的课。所在的院据说一直是考试平均分最高的。

早在遥远的中学(并不遥远)，就已经接触过C++，所以这个课程的压力并不大。不过正是因为提前接触过，所以才容易轻敌。况且，C和C++差别其实蛮大的（笑）。

讲道理，就一个学期，要学好个语言，对于咱这种姑且算是有点基础的人而言都做不到，就更别提那些之前没接触过的了。

---

## 说明

如果抱着想从零基础开始学的想法，还是另寻他处吧。

定位大概是学了但还处于懵懂的受众？(大雾)

其实咱也是懵懂的。

其实，这课程就是纯粹的语言学，和编程、逻辑等没太大关系，而后两者的这部分内容可能将来会写在其他地方吧。

---

## 知识体系

这门课其实并不涉及到原理，只是简简单单的停留在了语法层面。 How to make it work, and what it works like, and no need to know how they work.

如果孤立的来看C语言的话，你会发现C语言细节太多，你搞不清楚为什么会有那么多坑和反直觉的事情发生。C语言是一个和底层联系还算密切的语言。虽说可能比较生硬，但是说C语言和组成原理、汇编、编译课有紧密联系也完全没有什么问题。

---

## 一些概念(描述不一定准确，表意而已)

* 内存：在你电脑里面的东西。

* 寄存器：内存以外的一种可以存储数据的单元。离CPU很近存取速度很快，但是能存储的信息很少。电脑基本每条指令都涉及到寄存器。

* 头文件：.h结尾。不会实际被编译，而是会展开(复制-粘贴)到源文件中。

* 源文件：.c结尾。每个源文件编译**形成一个编译单元模块**，最后，所有源文件**链接成一个可执行文件**。

* 可执行文件：简单而言，Windows上的.exe .dll等文件。

* 编译：从程序语言到最终机器可以执行的可执行文件的过程或者其中的部分过程。由编译器完成。

* 变量：内存内有存储单元与之对应。

* 过程(函数)：一段独立的可重复使用的代码。实际上，过程离函数还是有些远的。咱个人是认为函数是完全封闭的，只要输入一样输出就一样；而过程因为可以存储全局的信息(全局变量)，所以同一个输入可能不同调用次数不同时间点的输出不一样。

* 类型：一个标识符(变量/过程)的属性。

* 变量/过程声明：告诉编译器某个变量/过程应有哪个属性。Declaration.

* 变量/过程定义：命令编译器为其分配空间(存储单元)。Defination.

* 栈：一个数据结构(存取数据的方式)。就是一个坑，往里面填东西，或者取出最顶上的东西。满足后进先出。虽然栈数据结构本身不允许，不过下面提到的栈是允许存取非顶部的元素的栈。

* 堆：一个可以随意使用(大雾)的可以存储很多东西的有很大存储空间的东西。

---

## 编译流程

若干头文件、源文件 -(宏展开预处理)-> 若干源文件 -(编译)-> 若干个二进制文件 -(链接)-> 一个可执行程序

---

## 计算机如何工作的？

从内存读取一条指令，执行，然后读取下一条指令，重复。

---

## 一些特殊寄存器

PC：程序指针。表示当前计算机执行到了哪个指令。

标志(flag)寄存器：用来存储当前计算机的状态。根据标志不同，计算机可以选择往下执行或者跳转到其他地方去。

栈寄存器：存储栈的栈顶在内存中的位置。

帧寄存器：存储栈帧的位置。简单而言，每次过程调用就会更新一次帧寄存器。

---

## 一个简单的计算机体系

先假设有一些寄存器，一个栈，有一个堆。下面把C代码大致翻译成相应的机器行为。

全局变量不带初始值的定义 -> 在堆上面开一块空间并且初始化为0。(暂不考虑强符号/弱符号与链接时的问题)

全局变量带初始值的定义 -> 在堆上面开一块空间，并且从你的可执行文件中把初始值拷贝过去。

静态变量定义 -> 在堆上面开一块空间并且从你的可执行文件中把初始值拷贝过去。

局部变量定义 -> 往栈里面开一块空间。

初始化 -> 当变量被定义时，以初始化的值被创建出来。

赋值 -> 与初始化概念完全不同。是把其他地方的值拷贝到这个地方来。

表达式 -> 借助寄存器，完成值的计算。

条件分支(if else while等) -> 先完成statement的计算，更新标志寄存器。然后根据标志寄存器来决定是否更改PC。

过程调用 -> 先计算参数，然后在栈里给参数分配空间。然后压栈压入PC和帧寄存器，改变帧寄存器到栈顶，然后再为过程内局部变量在栈上分配空间。

过程返回 -> 放弃局部变量，通过帧寄存器来找到旧的帧寄存器的位置，还原；然后清理掉参数的空间。过程返回值存在寄存器内。(暂不考虑结构体)

---

## 一些常见的坑及其解释

**宏，为同名替换。编译器看不到宏，而预处理中只会对宏展开**

避免使用宏函数，因为从来都是防不胜防。

```C
#define mult(x,y) x*y
int main() {
	mult(3+4,5+6); // --> 3+4*5+6=29 并非7*11=77
}
```
```C
#include<stdio.h>
#define maxer((x),(y)) ( (x)>(y)?(x):(y) )
//以为括号加的够多就安全了？
int main() {
	int x=1,y=2;
	int z=maxer(++x,++y);
	printf("%d %d %d",x,y,z); // 2 4 4
}
```

<br><br>

**越界的后果是不定的。**

在这个例子里，b[3]的位置和i的有可能一致，因为局部变量在栈上，靠的很近；那么这段代码就成了死循环了。

```C
#include<stdio.h>
int main() {
	long long int i;
	long long int b[3];
	for(i=0;i<=3;++i) {
		b[i]=0;
	}
	return 0;
}
```

<br><br>

**单向值传递**

因为计算机计算完参数后都会额外将数据压栈，你在过程中更改的参数都是那部分额外压的部分。过程结束后会清理那部分额外的，所以你做的都是无用功。

但是，你可以通过指针的方式，比如，从那个额外的的部分的数据能够寻找到另一处内存单元并对他进行修改，那么这个修改在过程结束后依然有效。

```C
void swap(int a,int b) {
	int temp;
	temp=a;a=b;b=temp;
} //wrong，额外的a和b在过程结束后被清理

void swap(int *a,int *b) {
	int temp;
	temp=*a;*a=*b;*b=temp;
} //ok，通过a和b寻找另一个内存单元。即使a和b被清理，寻找到的另一个内存单元的修改是有效的。
```

<br><br>

**未定义行为**

程序语言本身对一些奇怪的行为不去做定义，交由编译器自行裁决。

比如下例。i是存在内存中的。编译器可以在每次使用前都取一次i，使用完后立刻存入，也可以先暂存在寄存器内。实现不同，造成了结果不同。

```C
int i=1;
int j=(++i)+(++i)+(++i);
int k=(++i)+((++i)+(++i));
```

<br><br>

**左右值**

等号左边必须是左值，等号右边可以是右值或者当成右值使用的左值。不妨假设通过一次映射可以从左值得到其右值(简单而言，就相当于从内存地址(变量名)到取出内存数据的过程)。

左值在内存中是有相应的空间与之对应，而右值则可以是常量以及表达式计算中的临时值。

由于右值在内存中没有相应的存储单元，所以当然不能给右值赋值啦。

<br><br>

**局部变量不初始化的话，初始值不一定为0**

局部变量在栈上，而栈可以是先被填满，然后又空下来以后的栈。为局部变量分配空间的时候只是简单的将栈寄存器上移，表示额外占了空间；而里面的内容，是之前的活动余留下的。所以可以的话，还是尽量初始化为好。

**局部变量的地址不得被返回**

过程调用结束后，栈寄存器会下移表示释放空间，返回值会拷贝在寄存器内。但如果返回的是地址，那么虽然这个地址幸存下来，但其指向的栈里面的位置早已不复存在。

```C
char* func() {
	char a[]={"hello"};
	return a; //危险
}
```

<br><br>

**短路运算**

归根结底，就是在计算时偷懒，算完左边的就会有分支跳转，跳了以后右边的就没动了。

```C
int a=1;
int b=a||(++a); //++a并不会被计算。
int c=0;
int d=c&&(++c); //++c并不会被计算。
```

<br><br>

**编译时与运行时**

编译时就是在生成可执行文件之前发生，运行时就是你运行你的程序的时候。

类型推导发生在编译时。请看下面的程序：

```
int x=0;
int y=sizeof(++x);
```

由于sizeof是编译时计算(暂不考虑变长数组的运行时计算)，相当于程序在执行时只看到了int y=4; 所以里面的++x并不会被执行，x还是0，而不是1.

顺带一提，sizeof是关键、保留字而不是函数。sizeof(x)或者sizeof x，写法都是对的，虽然前者好看一点。

<br><br>

**结构体的数据对齐**

假设char1个字节，double8个字节，那么下面的struct多大(sizeof(struct stu))？答案是16个字节非9个字节。原因是如果b紧跟在a后面，那我们需要取1~7和第8个字节拼一起，还不如直接把b放在8~15字节上，省事。

内存的结构是，地址除8余0的在一个物理内存中，余1的在一个物理内存中，余2的在一个物理内存中...(视你的电脑CPU而定，不是4就是8)

内存只接受一个地址(首字节地址)，所以从0取到7可以瞬间取出，如果隔着的话，需要输入两次地址。

```C
struct stu {
	char a;
	double b;
};
```

[返回](/)